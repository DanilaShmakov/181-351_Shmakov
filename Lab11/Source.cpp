/*ДИНАМИЧЕСКОЕ НЕЯВНОЕ
- ЕХЕ становится в зависимости от FLL в момент компиляции
- Требуется подклбчение небольшой lib(объемом гораздо меньще, чем при статическом),
содержащей адреса на ф - йии в DLL
- DLL грузится в ОП в момент загрузки ЕХЕ, есди DLL не находится приложение выключается

 КАК ПОДКЛЮЧИТЬ НЕЯВНО ДИНАМИЧЕСКУЮ БИБЛИОТЕКУ
 в разделе ПРОЕКТ--свойства--компоновщик--общие--дополнительные каталоги библиотек--пишем адрес Lib
 затем в разделе ввод--дополнительные зависимости--пишем имя lib
 также в разделе С/С++ -- общие -- дополнительный каталог включаемых файлов -- подключаем адрес .h файлов
ДИНАМИЧЕСКОЕ ЯВНОЕ
- Прилодение грузит DLL в память с помощью социальной ф - ции LoadLibrary()
- Переде вызовом ф-ции приложение должно сначала найти еe в DLL по строковому имени с помощью ф-ции прототип_функции
GetProcAddress(HINSTSNCE ссылка_на_загруженную_DLL, "имя_функции")
- Если DLL не найдена, приложение технически может продолжать работу, но без ф - ции из DLL
УСТРАНЕНИЕ ОШИБОК
"Не нейдена библиотека" решения:
неправильный адрес
неправильное имя
неправильный формат
"Подчёркивает HINSTANCE" решения:
не подключена windows.h или подключена до других
"Не найдена функция" решения:
неправильно указана функция
неправильно указан прототип функции
в прототипе указаны переменные
*/
#include <iostream>
#include <Windows.h>
//typedef int(CALLBACK* fun)(int, int, int);
/*прототип
или объявление функции-инструкция для компилятора
в каком порядке и какого размера передавать в стек параметры
и какой выходной параметр
__stdcall - компилятор передает парметры в стек по порядку: p1,p2,p3
__cdecl - компилятор передает параметры в обратном порядке: p3,p2,p1
CALLBACK - псевдрним для__stdcall
*/
extern "C" __declspec(dllexport) int discrim(int a, int b, int c);
int main()
{
	/*HINSTANCE esh; //загрузка файла dll в ОП
//ссылка на загруженную dll, которая будет загружаться
	esh = LoadLibrary(L"C:/181-351-okunev/x64/Debug/din-lib.dll");
	std::cout << esh << std::endl;
	fun f1 = (fun)GetProcAddress(esh, "discrim");
	std::cout << f1 << std::endl;
	std::cout << f1(1, 5, 4);
	*/
	std::cout << discrim(1, 5, 4);
	return 0;
}